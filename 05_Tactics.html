<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2016-11-28 Mon 14:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Theorem Proving in Lean</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="[[http://www.andrew.cmu.edu/user/avigad][Jeremy Avigad]]Jeremy Avigad, [[http://leodemoura.github.io][Leonardo de Moura]]Leonardo de Moura, [[http://www.cs.cmu.edu/~soonhok][Soonho Kong]]Soonho Kong" />
<link rel="stylesheet" href="css/tutorial.css"/>
<link rel="stylesheet" href="css/code.css"/>
<script type="text/javascript" charset="utf-8">if(!window.PolymerGestures) { var head = document.getElementsByTagName('head')[0]; var js = document.createElement("script"); js.type = "text/javascript"; js.src = "//cdn.jsdelivr.net/webcomponentsjs/0.7.20/webcomponents.min.js"; head.appendChild(js); } </script>
<link rel='import' href='juicy-ace-editor.html'/>
</head>
<body>
<div id="content">
<h1 class="title">Theorem Proving in Lean</h1>

<div id="outline-container-org32b14b3" class="outline-2">
<h2 id="Tactics"><a id="org32b14b3"></a><span class="section-number-2"> 5</span> Tactics</h2>
<div class="outline-text-2" id="text-Tactics">
<p>
In this chapter, we describe an alternative approach to constructing
proofs, using <i>tactics</i>. A proof term is a representation of a
mathematical proof; tactics are commands, or instructions, that
describe how to build such a proof. Informally, we might begin a
mathematical proof by saying "to prove the forward direction, unfold
the definition, apply the previous lemma, and simplify." Just as these
are instructions that tell the reader how to find the relevant proof,
tactics are instructions that tell Lean how to construct a proof term.
They naturally support an incremental style of writing proofs, in
which users decompose a proof and work on goals one step at a time.
</p>

<p>
We will describe proofs that consist of sequences of tactics as
"tactic-style" proofs, to contrast with the ways of writing proof
terms we have seen so far, which we will call "term-style"
proofs. Each style has its own advantages and disadvantages. For
exmample, tactic-style proofs can be harder to read, because they
require the reader to predict or guess the results of each
instruction. But they can also be shorter and easier to
write. Moreover, tactics offer a gateway to using Lean's automation,
since automated procedures are themselves tactics.
</p>
</div>

<div id="outline-container-orge7f19ce" class="outline-3">
<h3 id="orge7f19ce"><span class="section-number-3"> 5.1</span> Entering Tactic Mode</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Conceptually, stating a theorem or introducing a <code>have</code> statement
creates a goal, namely, the goal of constructing a term with the
expected type. For example, the following creates the goal of
constructing a term of type <code>p ∧ q ∧ p</code>, in a context with constants
<code>p q : Prop</code>, <code>hp : p</code> and <code>hq : q</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-1' mode="ace/mode/lean" readonly="true">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
sorry
</juicy-ace-editor><div id='lean-full-code-1' style='display:none'>theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
sorry
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-1').text());">Try it yourself &raquo;</button></div>
</div>
<p>
We can write this goal as follows:
</p>
<div class="org-src-container">

<pre class="src src-text">p : Prop, q : Prop, hp : p, hq : q &#8866; p &#8743; q &#8743; p
</pre>
</div>
<p>
Indeed, if you replace the "sorry" by an underscore in the example
above, Lean will report that it is exactly this goal that has been
left unsolved.
</p>

<p>
Ordinarily, we meet such a goal by writing an explicit term. But
wherever a term is expected, Lean allows us to insert instead a <code>begin
... end</code> block, followed by a sequence of commands, separated by
commas. We can prove the theorem above in that way:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-3' mode="ace/mode/lean" readonly="true">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
begin
  apply and.intro,
  exact hp,
  apply and.intro,
  exact hq,
  exact hp
end
</juicy-ace-editor><div id='lean-full-code-3' style='display:none'>theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
begin
  apply and.intro,
  exact hp,
  apply and.intro,
  exact hq,
  exact hp
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-3').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The <code>apply</code> tactic applies an expression, viewed as denoting a
function with zero or more arguments. It unifies the conclusion with
the expression in the current goal, and creates new goals for the
remaining arguments, provided that no later arguments depend on
them. In the example above, the command <code>apply and.intro</code> yields two
subgoals:
</p>
<div class="org-src-container">

<pre class="src src-text">p : Prop,
q : Prop,
hp : p,
hq : q
&#8866; p

&#8866; q &#8743; p
</pre>
</div>
<p>
For brevity, Lean only displays the context for the first goal, which
is the one addressed by the next tactic command. The first goal is met
with the command <code>exact hp</code>. The <code>exact</code> command is just a variant of
<code>apply</code> which signals that the expression given should fill the goal
exactly. It is good form to use it in a tactic proof, since its
failure signals that something has gone wrong; but otherwise <code>apply</code>
would work just as well.
</p>

<p>
You can see the resulting proof term with the <code>print</code> command:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-5' mode="ace/mode/lean" readonly="true">print test</juicy-ace-editor><div id='lean-full-code-5' style='display:none'>theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
begin
  apply and.intro,
  exact hp,
  apply and.intro,
  exact hq,
  exact hp
end

print test
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-5').text());">Try it yourself &raquo;</button></div>
</div>

<p>
You can write a tactic script incrementally. If you run Lean on an
incomplete tactic proof bracketed by <code>begin</code> and <code>end</code>, the system
reports all the unsolved goals that remain. If you are running Lean
with its Emacs interface, you can see this information by putting your
cursor on the <code>end</code> symbol, which should be underlined. In the Emacs
interface, there is another extremely useful trick: if you put your
cursor on a line of a tactic proof and press "C-c C-g", Lean will show
you the goal that remains at the end of the line.
</p>

<p>
Tactic commands can take compound expressions, not just single
identifiers. The following is a shorter version of the preceding
proof:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-6' mode="ace/mode/lean" readonly="true">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
begin
  apply (and.intro hp),
  exact (and.intro hq hp)
end</juicy-ace-editor><div id='lean-full-code-6' style='display:none'>theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
begin
  apply (and.intro hp),
  exact (and.intro hq hp)
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-6').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Unsurprisingly, it produces exactly the same proof term.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-7' mode="ace/mode/lean" readonly="true">print test</juicy-ace-editor><div id='lean-full-code-7' style='display:none'>theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
begin
  apply (and.intro hp),
  exact (and.intro hq hp)
end

print test
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-7').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Whenever a proof term is expected, instead of using a <code>begin...end</code>
block, you can write the <code>by</code> keyword followed by a single tactic:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-8' mode="ace/mode/lean" readonly="true">theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
by exact and.intro hp (and.intro hq hp)
</juicy-ace-editor><div id='lean-full-code-8' style='display:none'>theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p :=
by exact and.intro hp (and.intro hq hp)
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-8').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In the Lean Emacs mode, if you put your cursor on the "b" in "by" and
press "C-c C-g", Lean shows you the goal that the tactic is supposed
to meet.
</p>
</div>
</div>

<div id="outline-container-org44ac449" class="outline-3">
<h3 id="org44ac449"><span class="section-number-3"> 5.2</span> Basic Tactics</h3>
<div class="outline-text-3" id="text-1-2">
<p>
In addition to <code>apply</code> and <code>exact</code>, another useful tactic is <code>intro</code>,
which introduces a hypothesis. What follows is an example of an
identity from propositional logic that we proved <a href="#" onclick="myModule.loadTutorial('03_Propositions_and_Proofs.org', 'Examples_of_Propositional_Validities')">Section 3.5</a> but now
prove using tactics. We adopt the following convention regarding
indentation: whenever a tactic introduces one or more additional
subgoals, we indent another two spaces, until the additional subgoals
are deleted.
</p>

<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-9' mode="ace/mode/lean" readonly="true">example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
begin
  apply iff.intro,
    intro h,
    apply (or.elim (and.elim_right h)),
      intro hq,
      apply or.intro_left,
      apply and.intro,
        exact (and.elim_left h),
      exact hq,
    intro hr,
    apply or.intro_right,
    apply and.intro,
    exact (and.elim_left h),
    exact hr,
  intro h,
  apply (or.elim h),
    intro hpq,
    apply and.intro,
      exact (and.elim_left hpq),
    apply or.intro_left,
    exact (and.elim_right hpq),
  intro hpr,
  apply and.intro,
    exact (and.elim_left hpr),
  apply or.intro_right,
  exact (and.elim_right hpr)
end
</juicy-ace-editor><div id='lean-full-code-9' style='display:none'>example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
begin
  apply iff.intro,
    intro h,
    apply (or.elim (and.elim_right h)),
      intro hq,
      apply or.intro_left,
      apply and.intro,
        exact (and.elim_left h),
      exact hq,
    intro hr,
    apply or.intro_right,
    apply and.intro,
    exact (and.elim_left h),
    exact hr,
  intro h,
  apply (or.elim h),
    intro hpq,
    apply and.intro,
      exact (and.elim_left hpq),
    apply or.intro_left,
    exact (and.elim_right hpq),
  intro hpr,
  apply and.intro,
    exact (and.elim_left hpr),
  apply or.intro_right,
  exact (and.elim_right hpr)
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-9').text());">Try it yourself &raquo;</button></div>
</div>

<p>
The <code>intro</code> command can more generally be used to introduce a variable of any type:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-10' mode="ace/mode/lean" readonly="true">example (A : Type) : A → A :=
begin
  intro a,
  exact a
end

example (A : Type) : ∀ x : A, x = x :=
begin
  intro x,
  exact eq.refl x
end
</juicy-ace-editor><div id='lean-full-code-10' style='display:none'>example (A : Type) : A → A :=
begin
  intro a,
  exact a
end

example (A : Type) : ∀ x : A, x = x :=
begin
  intro x,
  exact eq.refl x
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-10').text());">Try it yourself &raquo;</button></div>
</div>
<p>
It has a plural form, <code>intros</code>, which takes a list of names.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-11' mode="ace/mode/lean" readonly="true">example : ∀ a b c : nat, a = b → a = c → c = b :=
begin
  intros a b c h₁ h₂,
  exact eq.trans (eq.symm h₂) h₁
end
</juicy-ace-editor><div id='lean-full-code-11' style='display:none'>example : ∀ a b c : nat, a = b → a = c → c = b :=
begin
  intros a b c h₁ h₂,
  exact eq.trans (eq.symm h₂) h₁
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-11').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The <code>intros</code> command can also be used without any arguments, in which
case, it chooses names and introduces as many variables as it can. We
will see an example of this in a moment.
</p>

<p>
The <code>assumption</code> tactic looks through the assumptions in context of the
current goal, and if there is one matching the conclusion, it applies
it.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-12' mode="ace/mode/lean" readonly="true">example (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w :=
begin
  apply (eq.trans h₁),
  apply (eq.trans h₂),
  assumption   -- applied h₃
end</juicy-ace-editor><div id='lean-full-code-12' style='display:none'>variables x y z w : ℕ

example (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w :=
begin
  apply (eq.trans h₁),
  apply (eq.trans h₂),
  assumption   -- applied h₃
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-12').text());">Try it yourself &raquo;</button></div>
</div>
<p>
It will unify metavariables in the conclusion if necessary:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-13' mode="ace/mode/lean" readonly="true">example (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w :=
begin
  apply eq.trans,
  assumption,     -- solves x = ?b with h₁
  apply eq.trans,
  assumption,     -- solves ?b = w with h₂
  assumption      -- solves z = w with h₃
end</juicy-ace-editor><div id='lean-full-code-13' style='display:none'>variables x y z w : ℕ

example (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w :=
begin
  apply eq.trans,
  assumption,     -- solves x = ?b with h₁
  apply eq.trans,
  assumption,     -- solves ?b = w with h₂
  assumption      -- solves z = w with h₃
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-13').text());">Try it yourself &raquo;</button></div>
</div>
<p>
The following example uses the <code>intros</code> command to introduce the three
variables and two hypotheses automatically:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-14' mode="ace/mode/lean" readonly="true">example : ∀ a b c : nat, a = b → a = c → c = b :=
begin
  intros,
  apply eq.trans,
  apply eq.symm,
  assumption,
  assumption
end
</juicy-ace-editor><div id='lean-full-code-14' style='display:none'>example : ∀ a b c : nat, a = b → a = c → c = b :=
begin
  intros,
  apply eq.trans,
  apply eq.symm,
  assumption,
  assumption
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-14').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Incidentally, there are tactics <code>reflexivity</code>, <code>symmetry</code>, and
<code>transitivity</code>, which apply the corresponding operation. Using
reflexivity, for example, is more general than writing <code>apply
eq.refl</code>, because it works for any relation that has been tagged with
the <code>refl</code> attribute.
</p>

<p>
With that tactic, the previous proof can be written more elegantly as
follows:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-15' mode="ace/mode/lean" readonly="true">example : ∀ a b c : nat, a = b → a = c → c = b :=
begin
  intros,
  transitivity,
  symmetry,
  assumption,
  assumption
end
</juicy-ace-editor><div id='lean-full-code-15' style='display:none'>example : ∀ a b c : nat, a = b → a = c → c = b :=
begin
  intros,
  transitivity,
  symmetry,
  assumption,
  assumption
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-15').text());">Try it yourself &raquo;</button></div>
</div>


<p>
Another tactic that is sometimes useful is the <code>generalize</code> tactic,
which is, in a sense, an inverse to <code>intro</code>.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-16' mode="ace/mode/lean" readonly="true">variables x y z : ℕ

example : x = x :=
begin
  generalize x z, -- goal is x : ℕ ⊢ ∀ (z : ℕ), z = z
  intro y,      -- goal is x y : ℕ ⊢ y = y
  reflexivity
end
</juicy-ace-editor><div id='lean-full-code-16' style='display:none'>variables x y z : ℕ

example : x = x :=
begin
  generalize x z, -- goal is x : ℕ ⊢ ∀ (z : ℕ), z = z
  intro y,      -- goal is x y : ℕ ⊢ y = y
  reflexivity
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-16').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Te <code>generalize</code> tactic generalizes the conclusion over the variable
<code>x</code>, using a universal quantifier over <code>z</code>.  We generalize any term,
not just a variable:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-17' mode="ace/mode/lean" readonly="true">example : x + y + z = x + y + z :=
begin
  generalize (x + y + z) w, -- goal is x y z : ℕ ⊢ ∀ (w : ℕ), w = w
  intro u,                -- goal is x y z u : ℕ ⊢ u = u
  reflexivity
end</juicy-ace-editor><div id='lean-full-code-17' style='display:none'>variables x y z : ℕ

example : x + y + z = x + y + z :=
begin
  generalize (x + y + z) w, -- goal is x y z : ℕ ⊢ ∀ (w : ℕ), w = w
  intro u,                -- goal is x y z u : ℕ ⊢ u = u
  reflexivity
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-17').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Notice that once we generalize over <code>x + y + z</code>, the variables <code>x y
z : ℕ</code> in the context become irrelevant. The <code>clear</code> tactic throws
away elements of the context, when it is safe to do so:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-18' mode="ace/mode/lean" readonly="true">example : x + y + z = x + y + z :=
begin
  generalize (x + y + z) w, -- goal is x y z : ℕ ⊢ ∀ (w : ℕ), w = w
  clear x y z,
  intro u,                  -- goal is u : ℕ ⊢ u = u
  reflexivity
end</juicy-ace-editor><div id='lean-full-code-18' style='display:none'>variables x y z : ℕ

example : x + y + z = x + y + z :=
begin
  generalize (x + y + z) w, -- goal is x y z : ℕ ⊢ ∀ (w : ℕ), w = w
  clear x y z,
  intro u,                  -- goal is u : ℕ ⊢ u = u
  reflexivity
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-18').text());">Try it yourself &raquo;</button></div>
</div>

<p>
Another useful tactic is the <code>revert</code> tactic, which moves an element
of the context into the goal. When applied to a variable, it has the
same effect as <code>generalize</code> and <code>clear</code>:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-19' mode="ace/mode/lean" readonly="true">example (x : ℕ) : x = x :=
begin
  revert x,     -- goal is ⊢ ∀ (x : ℕ), x = x
  intro y,      -- goal is y : ℕ ⊢ y = y
  reflexivity
end
</juicy-ace-editor><div id='lean-full-code-19' style='display:none'>example (x : ℕ) : x = x :=
begin
  revert x,     -- goal is ⊢ ∀ (x : ℕ), x = x
  intro y,      -- goal is y : ℕ ⊢ y = y
  reflexivity
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-19').text());">Try it yourself &raquo;</button></div>
</div>
<p>
Moving a hypothesis into the goal yields an implication:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-20' mode="ace/mode/lean" readonly="true">example (x y : ℕ) (h : x = y) : y = x :=
begin
  revert h,     -- goal is x y : ℕ ⊢ x = y → y = x
  intro h₁,     -- goal is x y : ℕ, h₁ : x = y ⊢ y = x
  symmetry,
  assumption
end
</juicy-ace-editor><div id='lean-full-code-20' style='display:none'>example (x y : ℕ) (h : x = y) : y = x :=
begin
  revert h,     -- goal is x y : ℕ ⊢ x = y → y = x
  intro h₁,     -- goal is x y : ℕ, h₁ : x = y ⊢ y = x
  symmetry,
  assumption
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-20').text());">Try it yourself &raquo;</button></div>
</div>
<p>
But <code>revert</code> is even more clever, in that it will revert not only an
element of the context but also all the subsequent elements of the
context that depend on it. For exmaple, reverting <code>x</code> in the example
above brings <code>h</code> along with it:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-21' mode="ace/mode/lean" readonly="true">example (x y : ℕ) (h : x = y) : y = x :=
begin
  revert x,     -- goal is y : ℕ ⊢ ∀ (x : ℕ), x = y → y = x
  intros,
  symmetry,
  assumption
end
</juicy-ace-editor><div id='lean-full-code-21' style='display:none'>example (x y : ℕ) (h : x = y) : y = x :=
begin
  revert x,     -- goal is y : ℕ ⊢ ∀ (x : ℕ), x = y → y = x
  intros,
  symmetry,
  assumption
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-21').text());">Try it yourself &raquo;</button></div>
</div>
<p>
You can also revert multiple elements of the context at once:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-22' mode="ace/mode/lean" readonly="true">example (x y : ℕ) (h : x = y) : y = x :=
begin
  revert x y,     -- goal is x y : ℕ ⊢ ∀ (x : ℕ), x = y → y = x
  intros,
  symmetry,
  assumption
end
</juicy-ace-editor><div id='lean-full-code-22' style='display:none'>example (x y : ℕ) (h : x = y) : y = x :=
begin
  revert x y,     -- goal is x y : ℕ ⊢ ∀ (x : ℕ), x = y → y = x
  intros,
  symmetry,
  assumption
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-22').text());">Try it yourself &raquo;</button></div>
</div>
</div>
</div>


<div id="outline-container-orgee85b99" class="outline-3">
<h3 id="orgee85b99"><span class="section-number-3"> 5.3</span> The Rewrite Tactic</h3>
<div class="outline-text-3" id="text-1-3">
<p>
The <code>rewrite</code> tactic provide a basic mechanism for applying
substitutions to goals and hypotheses, providing a convenient and
efficient way of working with equality.
</p>

<p>
The <code>rewrite</code> tactic has many features. The most basic form of the
tactic is <code>rewrite t</code>, where <code>t</code> is a term which conclusion is an
equality. In the following example, we use this basic form to rewrite
the goal using a hypothesis.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-23' mode="ace/mode/lean" readonly="true">open nat
variables (f : nat → nat) (k : nat)

example (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 :=
begin
  rewrite h₂, -- replace k with 0
  rewrite h₁  -- replace f 0 with 0
end
</juicy-ace-editor><div id='lean-full-code-23' style='display:none'>open nat
variables (f : nat → nat) (k : nat)

example (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 :=
begin
  rewrite h₂, -- replace k with 0
  rewrite h₁  -- replace f 0 with 0
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-23').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In the example above, the first <code>rewrite</code> tactic replaces <code>k</code> with <code>0</code>
in the goal <code>f k = 0</code>.  Then, the second <code>rewrite</code> replace <code>f 0</code> with
<code>0</code>. The <code>rewrite</code> tactic automatically closes any goal of
the form <code>t = t</code>.
</p>

<p>
Multiple rewrites can be combined using the notation <code>rewrite [t_1,
..., t_n]</code>, which is just shorthand for <code>rewrite t_1, ..., rewrite
t_n</code>.  The previous example can be written as:
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-24' mode="ace/mode/lean" readonly="true">open nat
variables (f : nat → nat) (k : nat)

example (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 :=
begin
  rewrite [h₂, h₁]
end
</juicy-ace-editor><div id='lean-full-code-24' style='display:none'>open nat
variables (f : nat → nat) (k : nat)

example (h₁ : f 0 = 0) (h₂ : k = 0) : f k = 0 :=
begin
  rewrite [h₂, h₁]
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-24').text());">Try it yourself &raquo;</button></div>
</div>

<p>
By default, the <code>rewrite</code> tactic uses an equation in the forward
direction, matching the left-hand side with an expression, and
replacing it with the right-hand side. The notation <code>-t</code> can be used
to instruct the tactic to use the equality <code>t</code> in the reverse
direction.
</p>
<div class="org-src-container">
<juicy-ace-editor id='lean-juicy-ace-editor-25' mode="ace/mode/lean" readonly="true">open nat
variables (f : nat → nat) (a b : nat)

example (h₁ : a = b) (h₂ : f a = 0) : f b = 0 :=
begin
  rewrite [-h₁, h₂]
end
</juicy-ace-editor><div id='lean-full-code-25' style='display:none'>open nat
variables (f : nat → nat) (a b : nat)

example (h₁ : a = b) (h₂ : f a = 0) : f b = 0 :=
begin
  rewrite [-h₁, h₂]
end
</div><div class='no-print' align="left"><button type="button" onclick="invoke_leanjs($('#lean-full-code-25').text());">Try it yourself &raquo;</button></div>
</div>
<p>
In this example, the term <code>-h₁</code> instructs the <code>rewriter</code> to replace
<code>b</code> with <code>a</code>.
</p>
</div>
</div>
</div>
</div>
</body>
</html>
